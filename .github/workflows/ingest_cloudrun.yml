name: ingest_cloudrun

on:
  schedule:
    # 03:00 UTC daily (ajusta según tu zona horaria)
    - cron: "0 3 * * *"
  workflow_dispatch:
    inputs:
      force:
        description: "Forzar ingesta (true/false)"
        required: false
        default: "true"
      all_sources:
        description: "Ignorar toggles y probar todas las fuentes (true/false)"
        required: false
        default: "false"

concurrency:
  group: ingest-cloudrun
  cancel-in-progress: true

jobs:
  ingest:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    env:
      # No secretos: puedes moverlos a GitHub Variables si quieres
      GCP_PROJECT: global-overview-radar
      GCP_REGION: europe-southwest1
      BACKEND_SERVICE: gor-backend
      CALLER_SERVICE_ACCOUNT: gor-github-deploy@global-overview-radar.iam.gserviceaccount.com

      # OAuth client id (si tu política lo trata como secret, déjalo en secrets)
      AUTH_GOOGLE_CLIENT_ID: ${{ secrets.AUTH_GOOGLE_CLIENT_ID }}

    steps:
      - name: Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
         
          # GCP_WORKLOAD_IDENTITY_PROVIDER
          # Formato esperado:
          # projects/PROJECT_NUMBER/locations/global/workloadIdentityPools/POOL_ID/providers/PROVIDER_ID
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}

          # Tu service account “caller” (el que ya confirmaste)
          service_account: gor-github-deploy@global-overview-radar.iam.gserviceaccount.com

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v3

      - name: Resolve login bypass toggle (GitHub Actions secret)
        id: login_toggle
        env:
          RAW_LOGIN_REQUESTED: ${{ secrets.GOOGLE_CLOUD_LOGIN_REQUESTED }}
        run: |
          set -euo pipefail
          value="$(echo "${RAW_LOGIN_REQUESTED:-false}" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')"
          if [ "$value" != "true" ]; then
            value="false"
          fi
          echo "value=${value}" >> "$GITHUB_OUTPUT"
          echo "GOOGLE_CLOUD_LOGIN_REQUESTED=${value}"

      # Debug seguro (no imprime secretos). Si no lo necesitas, puedes borrarlo.
      - name: Debug identity
        run: |
          set -euo pipefail
          gcloud auth list
          echo "Active account: $(gcloud config get-value account)"
          echo "Project: $(gcloud config get-value project || true)"

      - name: Trigger backend ingest
        env:
          FORCE: ${{ github.event.inputs.force || 'true' }}
          ALL_SOURCES: ${{ github.event.inputs.all_sources || 'false' }}
        run: |
          set -euo pipefail

          LOGIN_REQUESTED="${{ steps.login_toggle.outputs.value }}"
          ADMIN_KEY=""

          if [ "${LOGIN_REQUESTED}" != "true" ]; then
            ADMIN_KEY="$(gcloud secrets versions access latest \
              --secret AUTH_BYPASS_MUTATION_KEY \
              --project "$GCP_PROJECT" 2>/dev/null || true)"
            ADMIN_KEY="$(echo "$ADMIN_KEY" | tr -d '\r\n')"
            if [ -z "${ADMIN_KEY}" ]; then
              echo "Missing AUTH_BYPASS_MUTATION_KEY secret while GOOGLE_CLOUD_LOGIN_REQUESTED=false."
              exit 1
            fi
            if [ "${#ADMIN_KEY}" -lt 32 ]; then
              echo "AUTH_BYPASS_MUTATION_KEY must be at least 32 characters."
              exit 1
            fi
          fi

          if [ "${LOGIN_REQUESTED}" = "true" ] && [ -z "${AUTH_GOOGLE_CLIENT_ID:-}" ]; then
            echo "Missing AUTH_GOOGLE_CLIENT_ID secret."
            exit 1
          fi

          # Obtener URL del backend
          BACKEND_URL="$(gcloud run services describe "$BACKEND_SERVICE" \
            --project "$GCP_PROJECT" \
            --region "$GCP_REGION" \
            --format 'value(status.url)')"

          if [ -z "$BACKEND_URL" ]; then
            echo "Failed to resolve backend URL."
            exit 1
          fi

          # Token para invocar Cloud Run (audience = URL del servicio)
          RUN_TOKEN="$(gcloud auth print-identity-token \
            --impersonate-service-account="$CALLER_SERVICE_ACCOUNT" \
            --audiences="$BACKEND_URL")"

          USER_TOKEN=""
          if [ "${LOGIN_REQUESTED}" = "true" ]; then
            # Token “usuario” para tu capa de auth (audience = OAuth client id)
            USER_TOKEN="$(gcloud auth print-identity-token \
              --impersonate-service-account="$CALLER_SERVICE_ACCOUNT" \
              --audiences="$AUTH_GOOGLE_CLIENT_ID" \
              --include-email)"
          fi

          COMMON_HEADERS=(-H "Authorization: Bearer ${RUN_TOKEN}")
          if [ -n "${USER_TOKEN:-}" ]; then
            COMMON_HEADERS+=(-H "x-user-id-token: ${USER_TOKEN}")
          fi
          if [ -n "${ADMIN_KEY:-}" ]; then
            COMMON_HEADERS+=(-H "x-gor-admin-key: ${ADMIN_KEY}")
          fi

          api_get() {
            curl -sS -f "$BACKEND_URL$1" \
              "${COMMON_HEADERS[@]}"
          }

          api_post() {
            local path="$1"
            local payload="$2"
            curl -sS -f -X POST "$BACKEND_URL$path" \
              "${COMMON_HEADERS[@]}" \
              -H "Content-Type: application/json" \
              -d "$payload"
          }

          wait_job() {
            local job_id="$1"
            echo "Ingest job started: $job_id"
            for i in {1..60}; do
              job="$(api_get "/ingest/jobs/$job_id")"
              status="$(printf '%s' "$job" | jq -r '.status')"
              echo "Status: $status"
              if [ "$status" = "success" ]; then
                echo "$job" | jq .
                return 0
              fi
              if [ "$status" = "error" ]; then
                echo "$job" | jq .
                return 1
              fi
              sleep 10
            done
            echo "Timeout waiting for ingest job."
            return 1
          }

          set_profile() {
            local source="$1"
            local profiles_json="$2"
            payload="$(jq -n --arg source "$source" --argjson profiles "$profiles_json" '{source:$source, profiles:$profiles}')"
            api_post "/reputation/profiles" "$payload" >/dev/null
            echo "Profile set to $source: $profiles_json"
          }

          start_ingest() {
            payload="$(jq -n --argjson force "$FORCE" --argjson all "$ALL_SOURCES" '{force:$force, all_sources:$all}')"
            response="$(api_post "/ingest/reputation" "$payload")"
            job_id="$(printf '%s' "$response" | jq -r '.id')"
            if [ -z "$job_id" ] || [ "$job_id" = "null" ]; then
              echo "No job id returned: $response"
              return 1
            fi
            wait_job "$job_id"
          }

          # Guardar perfil original
          current="$(api_get "/reputation/profiles")"
          orig_source="$(printf '%s' "$current" | jq -r '.active.source // "default"')"
          orig_profiles="$(printf '%s' "$current" | jq -c '.active.profiles // []')"
          echo "Original profile: ${orig_source} ${orig_profiles}"

          # Ejecutar dos ingestas
          set_profile "samples" '["banking_bbva_retail"]'
          start_ingest

          set_profile "samples" '["banking_bbva_empresas"]'
          start_ingest

          # Restaurar perfil original
          set_profile "$orig_source" "$orig_profiles"
